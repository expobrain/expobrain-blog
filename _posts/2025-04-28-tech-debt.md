---
class: post-template
comments: true
cover: media/tech_debt.png
current: post
date: 2025-04-28
layout: post
navigation: true
slug: tech-debt
subclass: post
tags:
  - engineering
  - tech debt
title: [Temporary] Tech debt
---

Technical debt is one of the primary sources of inefficiencies in software engineering and also one of the most challenging to prioritise, especially when it is not a direct and visible blocker for the business.

Tech debt can take various forms, including inefficient and convoluted code, incorrect software or system architecture, and suboptimal or outdated engineering operations. As a result, the topic is vast, with multiple strategies required to address each form, depending on company objectives, engineering capacity, and the impact of the technical debt.

In this post, we will focus on a subset of technical debt: codebase and software architecture. We will explore a method to programmatically identify areas of the codebase that require attention and re-architecture, as well as highlight hotspots where the majority of changes occur.

## Define code metrics

The first step is to determine the metrics needed to rank each file in the codebase. This is not a straightforward task, as code quality is difficult to define in a strict scientific manner. Many variables can be considered, such as the number of lines of code per file or function, the number of conditional statements, variable naming conventions, and more.

In software engineering, the [Maintainability Index](https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-maintainability-index-range-and-meaning) is often used to compute a value between 0 and 100 that indicates how maintainable the code is. This index consists of three main components:

* [Halstead Volume](https://en.wikipedia.org/wiki/Halstead_complexity_measures): A metric that evaluates the number of operations, operands, and their uniqueness in the code to compute a "volume" that relates to the amount of information in the analysed code.
* [Cyclomatic Complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity): A measure of code complexity based on the number of different paths and branches.
* Lines of Code: A simple yet effective metric that measures code length.

While these metrics are not perfect and have an empirical nature, they are easy to compute for any given programming language.

## Identify hotspots

To determine which files in the codebase are modified most frequently, we can extract this information from the Git history. By counting the number of commits for each file, we obtain valuable insights into areas of the codebase that experience frequent changes.

A high number of changes in a file can indicate a hotspot or even a bottleneck, depending on the file’s content, role, and the software architecture (or lack thereof) within the codebase. Conversely a low number of changes means that the file has less importance or has already reached a level where further changes are not necessary.

## Merging metrics together

By combining the Maintainability Index and Change Frequency, we can create a new metric called the Hotspot Index, which helps identify the least maintainable code with the highest number of modifications.

To compute the Hotspot Index, we calculate the ratio between Change Count and the Maintainability Index, amplifying the impact of lower maintainability values. The higher the Hotspot Index, the greater the likelihood that a file contains technical debt that should be addressed.

## How to compute all the metrics on a codebase

To streamline this analysis, we developed the [tech\_debt\_hotspot](https://github.com/expobrain/tech_debt_hotspot) tool. This command-line utility scans a given codebase, collects relevant metrics, and outputs the results in various formats, such as Markdown or CSV.

Here is an example of the tool in action, analysing the Django web framework [codebase](https://github.com/django/django):

```shell
tech\_debt\_hostpot django/django –sort hotspot\_index
```

This command scans the Django codebase (excluding tests) and generates a Markdown table, sorting the results in descending order by Hotspot Index. Below is an extract of the output:

```text
| path                                        | halstead\_volume    | cyclomatic\_complexity | loc  | comments\_percentage | maintainability\_index | changes\_count | hotspot\_index      |
|---------------------------------------------|--------------------|-----------------------|------|---------------------|-----------------------|---------------|--------------------|
| django/db/models/sql/compiler.py            | 74841.09447519094  |                    53 | 2215 |   18.78103837471783 |                     0 |           356 |                inf |
| django/db/backends/oracle/creation.py       | 11917.952738720745 |                    23 |  467 |  10.920770877944326 |   0.18321632269309265 |            88 |    48030.655078374 |
| django/forms/forms.py                       | 9932.302143552672  |                    16 |  439 |   26.42369020501139 |    0.5161767004565748 |           170 |  32934.45826780433 |
| django/db/backends/postgresql/operations.py | 12599.399135659465 |                    11 |  422 |  11.374407582938389 |    0.3015269070194827 |            97 |  32169.60003961852 |
| django/contrib/gis/gdal/raster/source.py    | 13687.088372788816 |                    27 |  541 |  24.214417744916823 |   0.11738302671413384 |            29 | 24705.445763146414 |
| django/core/management/\_\_init\_\_.py          | 10696.33990710387  |                    23 |  442 |  29.185520361990953 |    1.9748327748695045 |           176 |  8912.147005035904 |
| django/middleware/csrf.py                   | 9538.882040135086  |                    12 |  483 |   29.19254658385093 |     1.348214059411095 |            99 |  7343.047590175967 |
| django/core/management/commands/loaddata.py | 12303.106504600364 |                    12 |  433 |   8.545034642032332 |    1.8786503146700992 |           134 |  7132.780323917339 |
| django/utils/cache.py                       | 9527.093214317661  |                    17 |  444 |   31.53153153153153 |    1.3425663286539742 |            95 |  7076.000490437205 |
| django/db/migrations/loader.py              | 10374.36751811199  |                    19 |  418 |  26.076555023923444 |     1.520652170302934 |           106 |  6970.693368943365 |
| django/utils/text.py                        | 11154.541049194584 |                     7 |  479 |  23.799582463465555 |    2.0272047453429787 |           135 |  6659.416139890675 |
| django/db/migrations/serializer.py          | 11782.180473431079 |                    10 |  401 |   6.234413965087282 |    0.7200224978077625 |            45 |  6249.804712631975 |
```

One of the files with the highest Hotspot Index is `django/db/models/sql/compiler.py`, which has a Maintainability Index of zero and over 350 changes. Upon reviewing the file, it is evident that it could be refactored for better maintainability. Given the high number of modifications, this file is a prime candidate for addressing technical debt.

Sorting by Hotspot Index is not the only approach to analysing a codebase. Depending on the specific objectives, engineers may choose to prioritise by Change Count to focus on the most actively modified code or by Maintainability Index to identify the least maintainable code, irrespective of change frequency. Each of these strategies offers a different perspective, allowing teams to address technical debt in a way that aligns with their priorities.

## Conclusion

In this post, we explored a systematic approach to identifying technical debt hotspots in a codebase. By leveraging key metrics such as the Maintainability Index and Change Count, we can gain insights into which areas require refactoring. Additionally, we introduced the [tech\_debt\_hotspot](https://github.com/expobrain/tech_debt_hotspot) tool, which automates the collection and analysis of these metrics, enabling teams to make data-driven decisions about where to focus their efforts in tackling technical debt.
